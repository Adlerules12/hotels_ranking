# -*- coding: utf-8 -*-
"""final_project_example.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JuD9BHBdnMykIUp4Ol8g43dFH9NOzr0G
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from scipy.cluster.hierarchy import dendrogram, linkage
from sklearn.cluster import AgglomerativeClustering
from sklearn.metrics import roc_curve, auc, roc_auc_score
from sklearn import preprocessing
from sklearn.preprocessing import label_binarize
from sklearn.naive_bayes import GaussianNB
from sklearn.naive_bayes import MultinomialNB
from sklearn import tree
import matplotlib.pyplot as plt_mn
import pandas as pd
from pandas import Series, DataFrame
from sklearn import datasets
from sklearn import metrics
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
import numpy as np
from datetime import datetime
import csv
import calendar
import time
from google.colab import drive
drive.mount('/content/drive')
import os
# %cd /content/drive/My\ Drive/Colab\ Notebooks


def getPriceAccordingIndex(hotels,hotelName, checkinDate, discountCode):
  results = hotels.loc[(hotels['Hotel Name index']==hotelName) & (hotels['Checkin Date index'] == checkinDate) & (hotels['Discount Code'] == discountCode)]
  return -1 if results.size == 0 else results['Discount Price'].sort_values(ascending=True)[:1].values[0]

def get_model_rates(row, cmNB):
  rowNumber = row
  row -= 1
  TP, FN, FP, TN = 0, 0, 0, 0
  count, TPRate, FNRate, FPRate, TNRate = 0, 0, 0, 0, 0
  for i, currI in enumerate(cmNB):
    for j, currJ in enumerate(currI):
      if row == i and row == j:
        TP = TP + cmNB[i][j]
      if row == i and row != j:
        FN = FN + cmNB[i][j]
      if row != i and row == j:
        FP = FP + cmNB[i][j]
      if row != i and row != j:
        TN = TN + cmNB[i][j]
  
  TPRate = 0 if TP == 0 and FN == 0 else TP / (TP + FN)
  FNRate = 0 if FN == 0 and TP == 0 else FN / (FN + TP)
  FPRate = 0 if TN == 0 and FP == 0 else FP / (FP + TN)
  TNRate = 0 if TN == 0 and FP == 0 else TN / (TN + FP)
  print(f"Discount-Code#{rowNumber}: TP={TP} -> {TPnb1} | FP={FP} -> {FPnb1} | FN={FN} -> {FNnb1} | TN={TN} -> {TNnb1}")
  return TPRate, FNRate, FPRate, TNRate

def NormalizeTheData(Max, Min, V):
  New_Min, New_Max = 0, 100
  return (((V - Min)/(Max - Min)) * (New_Max - New_Min)) + New_Min

def llf(id):
  return HotelNames[id]

def plot_mn(exp_mn, pred_mn, n_classes=4):
  fpr_mn, tpr_mn, roc_auc_mn = dict(), dict(), dict()
  for i in range(n_classes):
    fpr_mn[i], tpr_mn[i], _ = roc_curve(exp_mn[:, i], pred_mn[:, i])
    roc_auc_mn[i] = auc(fpr_mn[i], tpr_mn[i])
        
  plt_mn.figure()      
  for i in range(n_classes):
    plt_mn.plot(fpr_mn[i], tpr_mn[i], label='ROC curve Discount Code ' + str(i+1) + ' (area = %0.2f)' % roc_auc_mn[i])

  plt_mn.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
  plt_mn.xlim([0.0, 1.0])
  plt_mn.ylim([0.0, 1.05])
  plt_mn.xlabel('False Positive Rate')
  plt_mn.ylabel('True Positive Rate')
  plt_mn.title('Receiver operating characteristic Naive Bayes')
  plt_mn.legend(loc="lower right")
  plt_mn.show()

# TODO: change the loop to pandas syntax:
# csvinput = pd.read_csv('hotels_data.csv')
# columns = list(csvinput.columns) + ['DayDiff', 'WeekDay', 'DiscountDiff', 'DiscountPerc']
# pd.DataFrame(columns=columns)
with open('hotels_data.csv', 'r') as csvinput:
  with open('hotels_data_changed.csv', 'w') as csvoutput:
    writer = csv.writer(csvoutput, lineterminator = '\n')
    reader = csv.reader(csvinput)
    all = []
    row = next(reader)
    row.append('DayDiff')
    row.append('WeekDay')
    row.append('DiscountDiff')
    row.append('DiscountPerc')
    all.append(row)
    
    for row in reader:
      snapshotString = row[1].split(' 0:00', 1)[0]
      snapshotDate = datetime.strptime(snapshotString, '%m/%d/%Y')
      checkinString = row[2].split(' 0:00', 1)[0]
      checkinDate = datetime.strptime(checkinString, '%m/%d/%Y')
      days = (checkinDate - snapshotDate).days
      row.append(days)
      row.append(calendar.day_name[checkinDate.weekday()])
      originalPrice = int(float(row[4]))
      discountPrice = int(float(row[5]))
      diff = originalPrice - discountPrice
      row.append(diff)
      row.append((diff / originalPrice)* 100)
      all.append(row)
    writer.writerows(all)

# read the file hotels
hotels = pd.read_csv('hotels_data_changed.csv', encoding='utf-8')
grouped = hotels.groupby(['Snapshot Date', 'Checkin Date', 'DayDiff', 'Hotel Name', 'WeekDay'])
idx = grouped['DiscountDiff'].transform(max) == hotels['DiscountDiff']
maximum_discount_diffs = hotels[idx]
maximum_discount_diffs = maximum_discount_diffs.drop_duplicates(subset=['Snapshot Date', 'Checkin Date', 'DayDiff', 'Hotel Name', 'WeekDay', 'DiscountDiff'])
maximum_discount_diffs.to_csv('maximun_score.csv', encoding='utf-8')
filterData = pd.read_csv('maximun_score.csv', encoding = 'utf-8')  
features = filterData[['Snapshot Date', 'Checkin Date', 'DayDiff', 'Hotel Name', 'WeekDay']].copy()
Ylabels = filterData['Discount Code'].copy()
filterData['Discount Code'].value_counts()
factorizeHotalName = pd.factorize(features['Hotel Name'])[0]
factorizeWeekDay = pd.factorize(features['WeekDay'])[0]
factorizeCheckinDate = pd.factorize(features['Checkin Date'])[0]
factorizeSnapshotDate = pd.factorize(features['Snapshot Date'])[0]
X  = features.copy()
X['Hotel Name'] = factorizeHotalName
X['WeekDay'] = factorizeWeekDay
X['Checkin Date'] = factorizeCheckinDate
X['Snapshot Date'] = factorizeSnapshotDate
X.to_csv('dataToWork.csv', encoding='utf-8')
dataToWork = pd.read_csv('dataToWork.csv', encoding = 'utf-8')

model = GaussianNB()
X_train, X_test, Y_train, Y_test = train_test_split(X, Ylabels, test_size=0.3, random_state=100)
NB = model.fit(X_train, Y_train)
predictedNB = model.predict(X_test)
expectedNB = Y_test
valueNB = metrics.accuracy_score(expectedNB, predictedNB)
cmNB = metrics.confusion_matrix(expectedNB, predictedNB)
print(valueNB, cmNB)
get_model_rates(1, cmNB)

exp = label_binarize(expectedNB, classes=[1, 2, 3, 4])
pred = label_binarize(predictedNB, classes=[1, 2, 3, 4])
n_classes, fpr, tpr, roc_auc = 4, dict(), dict(), dict()
for i in range(n_classes):
  fpr[i], tpr[i], _ = roc_curve(exp[:, i], pred[:, i])
  roc_auc[i] = auc(fpr[i], tpr[i])

plt.figure()
for i in range(n_classes):
  plt.plot(fpr[i], tpr[i], label='ROC curve Discount Code ' + str(i+1) + ' (area = %0.2f)' % roc_auc[i])
    
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic Naive Bayes')
plt.legend(loc="lower right")
plt.show()

X_train_mn, X_test_mn, Y_train_mn, Y_test_mn = train_test_split(X, Ylabels, test_size=0.3, random_state=100)
modelM = MultinomialNB()
modelM.fit(X_train_mn, Y_train_mn)
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
predictedNBMN = modelM.predict(X_test_mn)
# Actual Expected Outvomes
expectedNBMN = Y_test_mn
valueNBMN = metrics.accuracy_score(expectedNBMN, predictedNBMN)
cmNBMN = metrics.confusion_matrix(expectedNBMN, predictedNBMN)
print(valueNBMN, cmNBMN)

get_model_rates(1, cmNBMN)
plot_mn(label_binarize(expectedNBMN, classes=[1, 2, 3, 4]), label_binarize(predictedNBMN, classes=[1, 2, 3, 4]), n_classes=4)

clf = tree.DecisionTreeClassifier()
clf = clf.fit(X_train, Y_train)
predictedTree = clf.predict(X_test)
expectedTree = Y_test
valueTree = metrics.accuracy_score(expectedTree, predictedTree)
cmTree = metrics.confusion_matrix(expectedTree, predictedTree)
print(valueTree, cmTree)

get_model_rates(1, cmTree)

y = label_binarize(Ylabels, classes=[1, 2, 3, 4])
y_test = label_binarize(expectedTree, classes=[1, 2, 3, 4])
y_score = label_binarize(predictedTree, classes=[1, 2, 3, 4])
n_classes, fpr, tpr, roc_auc = y.shape[1], dict(), dict(), dict()
for i in range(n_classes):
  fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])
  roc_auc[i] = auc(fpr[i], tpr[i])

fpr["micro"], tpr["micro"], _ = roc_curve(y_test.ravel(), y_score.ravel())
roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])
roc_auc[2]
plt.figure()
lw = 2
plt.plot(fpr[0], tpr[0], color='darkorange', lw=lw, label='ROC curve Discount Code 1 (area = %0.2f)' % roc_auc[0])
plt.plot(fpr[1], tpr[1], color='red', lw=lw, label='ROC curve Discount Code 2 (area = %0.2f)' % roc_auc[1])
plt.plot(fpr[2], tpr[2], color='blue', lw=lw, label='ROC curve Discount Code 3 (area = %0.2f)' % roc_auc[2])
plt.plot(fpr[3], tpr[3], color='green', lw=lw, label='ROC curve Discount Code 4 (area = %0.2f)' % roc_auc[3])
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic Decision Tree')
plt.legend(loc="lower right")
plt.show()

hotels = pd.read_csv('hotels_data_changed.csv', encoding='utf-8', usecols =['Hotel Name','Checkin Date','Discount Code','Discount Price'])
factorizeCheckinDate = pd.factorize(hotels['Checkin Date'])[0]
factorizeHotalName = pd.factorize(hotels['Hotel Name'])[0]
hotels['Hotel Name index'] = factorizeHotalName
hotels['Checkin Date index'] = factorizeCheckinDate

hotelsWithMostRows = hotels.groupby(['Hotel Name']).size().sort_values(ascending=False)[:150]
hotelsIndexWithMostRows = hotels.groupby(['Hotel Name index']).size().sort_values(ascending=False)[:150]
OneHundredFiftyHotels = hotelsWithMostRows.index
OneHundredFiftyHotelsIndex = hotelsIndexWithMostRows.index
hotelNameMatrix = DataFrame({'Hotel Name': OneHundredFiftyHotels, 'Hotel Name index': OneHundredFiftyHotelsIndex})
df_filtered = hotels.loc[hotels['Hotel Name'].isin(OneHundredFiftyHotels)]
mostCheckinDateRows = df_filtered.groupby(['Checkin Date']).size().sort_values(ascending=False)[:40]
mostCheckinDateRowsIndex = df_filtered.groupby(['Checkin Date index']).size().sort_values(ascending=False)[:40]
mostCheckinDateRows = mostCheckinDateRows.index
mostCheckinDateRowsIndex = mostCheckinDateRowsIndex.index
checkinDateMatrix = DataFrame({'Checkin Date': mostCheckinDateRows, 'Checkin Date index': mostCheckinDateRowsIndex})

cols, rows = 161, 151
matrix = [[0 for x in range(cols)] for y in range(rows)]
matrix[0][0] = 'Hotel Name'
counter = 1
size = [1,2,3,4]
for currDate in mostCheckinDateRows:
  for currIndex in size:
    newColumn = currDate + "_" + str(currIndex)
    matrix[0][counter] = newColumn;
    counter = counter + 1
        
for HotelIndex,CurrHotelName in enumerate(OneHundredFiftyHotels):
  matrix[HotelIndex + 1][0] = CurrHotelName
    
for RowIndex in range(1, rows):
  for ColIndex in range(1, cols):
    matrix[RowIndex][ColIndex] = -1

NewHotelsDF = pd.DataFrame(matrix)
NewHotelsDF.to_csv('ex3_NewHotelData.csv', encoding='utf-8', header=None)
NewHotelsFile = pd.read_csv('ex3_NewHotelData.csv', encoding='utf-8')
NewHotelsFile = NewHotelsFile.loc[:, ~NewHotelsFile.columns.str.contains('^0')]

rowSize, colSize = NewHotelsFile.index.size, NewHotelsFile.columns.size
for currRow in range(1,rowSize):
  for currCol in range(1,colSize):
    hotelName = matrix[currRow][0]
    checkinDate = matrix[0][currCol].split('_')[0]
    discountCode = int(matrix[0][currCol].split('_')[1])
    hotelNameIndex = hotelNameMatrix.loc[(hotelNameMatrix['Hotel Name'] == hotelName)]['Hotel Name index'].values[0]
    checkinDateIndex = checkinDateMatrix.loc[(checkinDateMatrix['Checkin Date'] == checkinDate)]['Checkin Date index'].values[0]
    newPrice = getPriceAccordingIndex(hotels,hotelNameIndex,checkinDateIndex,discountCode)
    matrix[currRow][currCol] = newPrice

NewHotelsDF = pd.DataFrame(matrix)
NewHotelsDF.to_csv('ex3_NewHotelData.csv', encoding='utf-8', header=None)
NewHotelsFile = pd.read_csv('ex3_NewHotelData.csv', encoding='utf-8')
NewHotelsFile = NewHotelsFile.loc[:, ~NewHotelsFile.columns.str .contains('^0')]

Min, Max = matrix[1][1], matrix[1][1]
for currRow in range(1, rowSize):
  for currCol in range(1, colSize):
    if matrix[currRow][currCol] != -1:
      # find min
      if Min > matrix[currRow][currCol]:
        Min = matrix[currRow][currCol]
      if Max < matrix[currRow][currCol]:
        Max = matrix[currRow][currCol]

for currRow in range(1,rowSize):
  for currCol in range(1,colSize):
    if matrix[currRow][currCol] != -1:
      matrix[currRow][currCol] = int(NormalizeTheData(Max,Min,matrix[currRow][currCol]))

NewHotelsDF = pd.DataFrame(matrix)
NewHotelsDF.to_csv('ex3_NewHotelDataNormalize.csv', encoding='utf-8', header=None)

NewHotelsFile = pd.read_csv('ex3_NewHotelDataNormalize.csv', encoding='utf-8')
NewHotelsFile = NewHotelsFile.loc[:, ~NewHotelsFile.columns.str.contains('^0')]

HotelNames = NewHotelsFile['Hotel Name'].copy()
factorizeHotelNames = pd.factorize(NewHotelsFile['Hotel Name'])[0]
NewHotelsFile['Hotel Name'] = factorizeHotelNames

ward = AgglomerativeClustering(n_clusters=2, linkage='ward')
ward.fit(NewHotelsFile)

Z = linkage(NewHotelsFile, 'ward')
plt.figure(figsize=(25, 10))
plt.title('Hierarchical Clustering Dendrogram')
plt.xlabel('Hotel Index')
plt.ylabel('Distance')
dendrogram(Z,
  leaf_rotation=90.,  # rotates the x axis labels
  leaf_font_size=8.,  # font size for the x axis labels
  leaf_label_func=llf)
plt.show()